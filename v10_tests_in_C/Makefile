# override the default CFLAGS variables used by Makefile
# -std=c11				2011 revision of the ISO C standard
#
# -g							something related to debugging
#
# -fno-common			compiler places uninitialized global variables in the BSS
#				          section of the object file
CFLAGS=-std=c11 -g -fno-common

#
# wildcard function is necessary here to expand the wildcard into
# "all files ending with .c", else SRCS is set to "*.c" literally
#
SRCS=$(wildcard *.c)

#
# performs a substitution .c --> .o in the variables SRCS
# they gave the same example in GNU's documentation :)
# foo := a.o b.o l.a c.o
# bar := $(foo:.o=.c)
#
OBJS=$(SRCS:.c=.o)

#
# TEST_SRC is replaced by the paths to all the .c files in the test/
# directory, test/a.c, test/b.c ...
#
TEST_SRCS=$(wildcard test/*.c)

# replaces the .c by .exe in the variables TEST_SRCS
TESTS=$(TEST_SRCS:.c=.exe)

#
# chibicc depends on all the .o files in the current directory which are
# specified as prerequisites
#
# $@ 	variable refers to the target itself
#
# $^ 	variable refers to the list of all the prerequisites of the
# 		rule, including the names of the directories in which they were found
#
# CC 	is by default set to cc by make
#
# LDFLAGS is empty by default
# 
chibicc: $(OBJS)
	$(CC) $(CFLAGS) -o $@ $^ $(LDFLAGS)

$(OBJS): chibicc.h

#
# %.exe allows to match any target ending in .exe inside the test/ directory
#
#
# -E
#  	 Just runs the preprocessor
#
#	-P	
#		 Inhibit generation of linemarkers in the output from the preprocessor.
#		 This might be useful when running the preprocessor on something that is
#		 not C code, and will be sent to a program which might be confused by the 
#		 linemarkers
#
#		 basically, the lines beginning with # that appear in the beginning of the 
#		 preprocessor's output are not included
#
# -C
# 	Do not discard comments.  All comments are passed through to the output file
#
# -x c common
#  	basically means that compile the file "common" assuming that the language is C
#  	(this might be given because there is no .c extension to common)
#
test/%.exe: chibicc test/%.c
	$(CC) -o- -E -P -C test/$*.c | ./chibicc -o test/$*.s -
	$(CC) -o $@ test/$*.s -xc test/common

# an example of how testing works:
# these are the files atih.c and test.h
# variable.c:
#
# #include "test.h"
#
# int g1, g2[4];
# 
# int main() {
# 	ASSERT(3, ({ int a; a=3; a; }));
# 	ASSERT(3, ({ int a=3; a; }));
# 	ASSERT(8, ({ int a=3; int z=5; a+z; }));
# 	printf("OK\n");
# 	return 0;
# }
#
# test.h:
#
#	define ASSERT(x, y) assert(x, y, #y)
#
#
#	This ASSERT() macro basically calls the assert() function that is in 
#	a file named "common"
#
#	common:
#
# #include <stdio.h>
# #include <stdlib.h>
#
# void assert(int expected, int actual, char *code) {
#  	if (expected == actual) {
#    	printf("%s => %d\n", code, actual);
#  	} else {
#    	 printf("%s => %d expected but got %d\n", code, expected, actual);
#   	 exit(1);
# 	}
# }
#
# this assert() function basically checks if the actual value that is to be
# returned by the string code matches the expected, and prints
# the result
#
# Now, when variable.c is compiled with options -E, -P and -C
# we get:
#
# /* ... some comments kept by -C option ...
#  */
#
# int g1, g2[4];
# int main() {
#		assert(3, ({ int a; a=3; a; }), "({ int a; a=3; a; })");
#		assert(3, ({ int a=3; a; }), "({ int a=3; a; })");
#		assert(8, ({ int a=3; int z=5; a+z; }), "({ int a=3; int z=5; a+z; })");
#		assert(3, ({ int a=3; a; }), "({ int a=3; a; })");
#		printf("OK\n");
#		return 0;
#	}
#
#
#	Now, the assembly code for this output is generated by running chibicc
#	on it, by piping the cc command to ./chibicc -o test/variable.s
#
#	Thus, variable.s contains 
#		calls to assert() function (that is yet to be declared)
#		each call contains parameters that are passed to it, 
#		assert(e, a, c)
#			e: expression that is just a number
#			a: this is a statement expression, thus it will be dealt with by
#				 chibicc as a block that returns a value!!
#				 this will be passed as the second parameter as the "actual" value
#			c: the same code that is just put in a string
#
#		after each call to assert(), there is a call to printf() that
#		just takes the string literal "OK"
#
#	Now, this variable.s is assembled and then linked with the object code of common
#	which is compiled using -xc (indicating that "treat common as if it is written in C")
#	this is required so that common will not be compiled along with the otherr test files
# and hence we cannot name common as common.c
#
# cc variable.s -o variable.exe -xc common
#
# Now, basically the calls to assert(), printf() etc can be linked to the object
# code in common that contians the declarations of these functions
# 
# We now have an executable that can be run directly!!
#

# 
# for running the executables, there is this target defined
#
# for each i in the prerequisites of target "test"
# run that executable
# and then ||  (proceed to exit if the result of that executable is false)
#
# result is false when actual != expected in some compiled code, and thus
# assert() in file common calls exit(1), thus making the exit status of that
# executable 1
#
# even though the exit status is 1, an exit status of 0 indicates success in the
# shell and thus the shell will need to execute the next command for evaluating the
# truth value of the logical OR (||) of both commands
#
# boolean short circuiting makes exit 1 not execute when the exectuable returns exit
# status 0, indicating success :)
#
test: $(TESTS)
	for i in $^; do echo $$i; ./$$i || exit 1; echo; done
	test/driver.sh

# clean all the temporaries, assembly files, exectutables etc
clean:
	rm -rf chibicc tmp* $(TESTS) test/*.s test/*.exe
	find * -type f '(' -name '*~' -o -name '*.o' ')' -exec rm {} ';'

.PHONY: test clean















